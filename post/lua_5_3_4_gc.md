## lua5.3.4 gc实现

之前对lua的gc实现只是了解个大概，多数是在遇到问题的时候看特定的gc代码。对于细节实现并没有花时间认真查看，最近由于工作上的一些原因需要协助其他童鞋对gc做一定的优化，所以决定花时间认真阅读了lua 5.3.4版本的gc实现，感觉还是收获挺多的，之前不了解的地方也豁然开朗了，对lua 整个gc的工作流程又熟悉了几分。 
于是就想把之前丢掉的blog给从新拿起来，记录下自己这两天的一些收获和见解。 ;D

----

所有脱离了语言特性和应用环境而去谈论gc的实现和方法都是在耍流氓。gc是对语言内部对象的管理；语言特性不同，选择的策略不同。虽然同样都是用标记清除，但是实现的复杂度和难度确相差甚远。对于lua gc来说因为`weak table`,`__gc`元方法还有分步的策略选择，让简单的标记回收的实现复杂度上升好几个数量级。

### 标记回收
lua使用的是mark-sweep(标记回收)的方式来实现gc的。 对于整个系统中被gc管理的对象有: `proto`,`closure`, `table`,`coroutine`, `userdata`, `string`(分为`short string`和`long string`)。每当这些对象被创建时多数是被挂载到`allgc`链表中.

mark时会从整个state的根节点开始遍历标记。每个对象被标记时会有三种状态, `white`, `black`和`gray`。 `white`表示当前已经没有被人引用，`black`表示当前还有被人引用，`gray`为还未标记.